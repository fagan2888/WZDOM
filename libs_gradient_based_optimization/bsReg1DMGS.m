function [f, g, data] = bsReg1DMGS(x, data, isInitial)
%% Regularization function, return the value and gradient of function $|Dx|_1$ using minimum gradient support function
% Bin She, bin.stepbystep@gmail.com, March, 2019
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INPUT
%
% x             is a column vector; refers to the parameter to be estimated.
%
% data.diffOrder is a scalar; refers to the order of difference operator D
% (D will be generated by this parameter, defaut data.diffOrder is 1,
% meaning D is a first-order difference operator.
% 
% data.nSegments is a scalar; refers to how many parts n is. For example, 
% for pre-stack three-term AVO inversion, nsegments is 3.
%
% isInitial is a logical; if it is true, the function will only perform
% some initial steps.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OUTPUT
% f             is a scalar; refers to sum( (Dx o Dx) / ((Dx o Dx) + beta^2)
%
% g             is a column vector; refers to the gradient of 
% sum( (Dx o Dx) / ((Dx o Dx) + beta^2) with respect to x.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % if the funcion is called at first time and the difference matrix D is
    % not given, we first generate the difference matix D and save it in
    % data.
    if nargin == 3 && isInitial && (~isfield(data, 'D') || isempty(data.D))
        [~, data] = bsGetFieldsWithDefaults(data, {'diffOrder', 1; 'nSegments', 1; 'beta', 0.1});
        validateattributes(data.diffOrder, {'double'}, {'>=', 1, '<=', 3});
        data.D = bsGen1DDiffOperator(length(x), data.nSegments, data.diffOrder);
        data.D = data.D / data.beta;
%         return;
    end
    
%     beta2 = data.beta * data.beta;
    
    z = data.D * x;
    z2 = z .^ 2;
    denom = z2 + 1;
    
    t1 = z2 ./ denom;
    g1 = (2*z) ./ denom;
%     g2 = -(2*z.^3) ./ (denom.^2);
    
    f = sum(t1);
    g = data.D' * (g1 .* (1 - t1));
end